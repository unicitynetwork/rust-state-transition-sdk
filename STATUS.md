# Rust SDK Status Report

## What Works

- **Genesis transaction verification**: Full cryptographic validation including CBOR encoding, Merkle path reconstruction, root hash verification, and request ID matching
- **Token-bound MaskedPredicate address computation**: Correctly computes addresses using modified 6-element CBOR array with double-encoded tokenType
- **Address checksum handling**: Proper validation and generation of 4-byte checksums (SHA256(imprint)[0:4])
- **MaskedPredicate signature verification**: Validates transaction authorization via ECDSA signatures (nonce revelation is optional)
- **Test suite**: All 13 ignored tests passing
- **Transfer transaction CBOR encoding**: Generates valid CBOR for both JSON-deserialized and programmatically-created predicates

## What Doesn't Work

### Token Validation with UnmaskedPredicate Transfers

The `token-javasdk.json` file fails validation with transaction chain mismatch:

```
Transaction 0 recipient:     DIRECT://00009a72d863cdccc0f62213244d43ca71a448460e85c5dd1ee79d3ccced31027cba999656f1
Transaction 1 source pubkey: 029010912eeac4e9e2e619dc958146eaeeb58fa82dba0833e1549dee7dce0a2dc7
Transaction 1 computed hash: 000095c1a8a25753c64582666ae4c4deef1782db9549f98398a2e29435661f81e2e5

❌ Hashes don't match!
```

### Specific Issues

1. **Transaction chain broken at index 1**: The source state predicate address (computed from UnmaskedPredicate) does not match the previous transaction's recipient address

2. **UnmaskedPredicate address computation**: Our implementation uses `SHA256([type_byte, public_key])` which produces `000095c1...`, but the JSON contains recipient address `00009a72...`

3. **Address format discrepancy**: The recipient addresses in the JSON appear to be computed differently than what our algorithm produces

## Why It Doesn't Work

### Root Cause

The token-javasdk.json file appears to have structurally invalid transaction chains. The recipient address from Transaction 0 does not correspond to the public key in Transaction 1's source predicate using standard UnmaskedPredicate address computation.

### Possible Explanations

1. **Java SDK may be incomplete/broken for UnmaskedPredicate transactions**: User has confirmed that Java SDK with only MaskedPredicates works correctly, but tokens with UnmaskedPredicate transfers fail

2. **Different address computation for UnmaskedPredicates**: There may be an undocumented address computation method for UnmaskedPredicates in transfer transactions that differs from the standard `SHA256([type_byte, pubkey])`

3. **Token file corruption**: The token-javasdk.json may have been generated incorrectly or modified after generation

### What We've Validated

- ✅ **MaskedPredicate-only tokens verify correctly** (per user testing with Java SDK)
- ✅ **Genesis transaction verification works** (cryptographically sound)
- ✅ **Address checksums are correct** (matches Java SDK format)
- ✅ **CBOR encoding matches Java SDK** (verified with debug output)
- ❌ **UnmaskedPredicate transaction chains fail** (addresses don't match)

## Next Steps

To resolve this issue, we need:

1. **Java SDK source code review**: Examine how UnmaskedPredicate addresses are computed in transfer transactions
2. **Working token with UnmaskedPredicate**: Obtain a token generated by Java SDK that successfully validates AND contains UnmaskedPredicate transfers
3. **Debug output from Java SDK**: Get detailed address computation steps for UnmaskedPredicate in the working token
4. **Specification clarification**: Determine if UnmaskedPredicates use different address computation in different contexts (genesis vs transfer)
